<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title> object</title>
<style>

</style>
</head>
<body>
	
</body>
<script>
/*1.通过new Object类创建对象,并为其添加属性和方法
	var person = new Object();
	person.name = 'Nicholas';
	person.age = 29;
	person.job = 'Software Engineer';
	person.sayName = function(){
		console.log(this.name);
	};
	person.sayName();
*/
/*2.通过对象初始化表达式创建对象
	var person = {
		name:'Nicholas',
		age:29,
		job:"Software Engineer",
		sayName:function(){
			console.log(this.name);
		}
	};
*/
/*3.属性的特性 
			 Object.defineProperty()方法
			 					接收三个参数:
			 								属性所在对象,属性名,描述符
			 								描述符:configurable
			 									   enumerable
			 									   writalbe
			 									   value
	var person = {};
	Object.defineProperty(person,'name',{
		writable:false,
		value:'Nicholas'
	});
	console.log(person.name);
	person.name = 'Greg';
	console.log(person.name);
*/
/*4.Object.defineProperty()方法可以修改configurable
	configurable一旦设置false,除了writable特性其他不能修改
	var person = {};
	Object.defineProperty(person,'name',{
		configurable:false,
		value:'Nicholas'
	});
	console.log(person.name);
	delete person.name;
	console.log(person.name);
*/
/*5.访问器属性,设置一个属性的值导致其他属性发生变化
	var book = {
		_year:2004,
		edition:1
	};
	Object.defineProperty(book,'year',{
		get:function(){
			return this._year;
		},
		set:function(newValue){
			if(newValue>2004){
				this._year = newValue;
				this.edition+=newValue - 2004;
			}
		}
	});
	book.year=2005;
	console.log(book.edition);
*/
/*6.不支持Object.defineProperty()方法的浏览器上用
	_defineGetter_()
	_defineSetter_()
	var book = {
		_year:2004,
		edition:1
	};
	book._defineGetter_('year',function(){
		return this._year;
	});
	book.defineSetter_('year',function(){
		if(newValue>2004){
			this._year=newValue;
			this.edition+=newValue-2004;
		}
	});
	book.year=2005;
	console.log(book.edition);
*/
/*7.定义多个属性
	Object.definePropertise()
	var book = {};
	Object.defineProperties(book,{
		_year:{
			writable:true,
			value:2004
		},
		edition:{
			writable:true,
			value:1
		},
		year:{
			get:function(){
				return this._year;
			},
			set:function(newValue){
				if(newValue>2004){
					this._year = newValue;
					this.edition +=newValue - 2004;
				}
			}
		}
	});
*/	
/*8.Object.getOwnPropertyDescriptor()
		读取属性描述符得到的是一个对象
	var book = {};
	Object.defineProperties(book,{
		_year:{value:2004},
		edition:{value:1},
		year:{get:function(){return this._year},set:function(){
			if(newValue>2004){
				this._year=newValue;
				this.edition+=newValue-2004
				}
		}
		}
	});
	var descriptor = Object.getOwnPropertyDescriptor(book,'_year');
	console.log(descriptor.value);
	var descriptor2 = Object.getOwnPropertyDescriptor(book,'year');
	console.log(descriptor2.get);
*/	
/*9.工厂模式
			抽象了,创建具体对象的过程
			用函数封装了以特定界都创建对象的细节
	function createPerson(name,age,job){
		var o = new Object();
		o.name = name;
		o.age = age;
		o.job = job;
		o.sayName  = function(){
			console.log(this.name);
		};
		return o;
	}
	var person1 = createPerson('Nicholas',29,'Software Engineer');
	var person2 = createPerson('Greg',27,'Doctor');
*/
/*10.自定义构造函数
	function Person(name,age,job){
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = function(){
			congsole.log(this.name);
		};
	}
	var person1 = new Person('Nicholas',29,"Software Enginner");
	var person2 = new Person('Greg',27,'Doctor');
*/
/*11.构造函数当做函数来用
				全局函数
				在特定作用域中调用,call()和apply()
	var person = new Person('Nicholas',29,"SoftwareEngineer");
	person.sayName();//作为构造函数
	Person('Greg',27,'Doctor');
	window.sayName();//Greg,普通函数
	var o = new Object();
	Person.call(o,'Kristen',25,'Nurse');
	o.sayName();//Kristen
*/
/*12.构造函数创建对象有缺点
	function Person(name,age,job){
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = new Function('console.log(this.name)');
	}
*/
/*//13.原型模式创建对象
	function Person(){

	};
	Person.prototype.name='Nicholas';
	Person.prototype.age=29;
	Person.prototype.job='Software Enginneer';
	Person.prototype.sayName=function(){
		console.log(this.name);
	};
	var person1 = new Person();
	person1.sayName();
	var person2 = new Person();
	person2.sayName();
	console.log(person1.sayName==person2.sayName);
*/
/*14.准确判断变量是不是数组类型方法一:
	Array.isArray();
	方法二:
			obj instanceof func
	var arr = [1,2,3];
	console.log(Array.isArray(arr));
*/
/*15.原型规则5条
	var obj = {};//每个引用类型具有对象特性即可自由扩展属性
	var obj = new Object();
	var arr = [];
	function fn(){};
	console.log(obj.__proto__);//每个对象都要一个隐式原型__proto__
	console.log(arr.__proto__);
	console.log(fn.__proto__);
	console.log(fn.prototype);//所以的函数都有一个显示原型prototype
	console.log(obj.__proto__===Object.prototype);//所以引用类型的隐式原型__proto__指向它的构造函数的prototype
	console.log(Object.prototype);
	function Foo(name,age){
		this.name = name;
	}
	Foo.prototype.alertName=function(){
		alert(this.name);
	}
	var f = new Foo('zhangsan');
	f.printName = function(){
		console.log(this.name);
	}
	f.printName();
	f.alertName();//对象f上没有alertName属性,那么它会在它的构造函数的prototype中寻找
*/
/*16.for in 循环对象属性
	for(var proName in window){
		document.write(proName);
	}
*/
/*17.for in 枚举出对象中的属性
	通过对象.hasOwnProperty(属性)得到对象本身的属性
	function Foo(name,age){
		this.name = name;
	}
	Foo.prototype.alertName=function(){
		alert(this.name);
	}
	var f = new Foo('zhangsan');
	f.printName = function(){
		console.log(this.name);
	}
	f.printName();
	f.alertName();
	var  item;
	for (item in f){
		if(f.hasOwnProperty(item)){
			console.log(item);
		}
		
	}
*/
/*18.原型链
	function Foo(name,age){
		this.name = name;
	}
	Foo.prototype.alertName = function(){
		alert(this.name);
	}
	var f = new Foo('zhangsan');
	f.printName=function(){
		console.log(this.name);
	}
	f.printName();
	f.alertName();
	console.log(f.toString());
*/
/*19.instanceof 通过原型链判断引用类型属于哪个构造函数
	var arr=[];
	console.log(arr instanceof Array);
	console.log(arr instanceof Object);//先从自身__proto__找,
	找到构造函数的prototype,再通过构造函数的__proto__找至到找到null
*/
	
</script>
</html>