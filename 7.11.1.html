<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title> </title>
<style>

</style>
</head>
<body>
	
</body>
<script>
/*1.任何变量(函数也视为变量),如果没有在当前函数作用域中找到,就会继续往上查找,最后如果在全局作用域中也没有找到,则报ReferenceError
	window.alert('调用window.alert()');
	var old_alert = window.alert;
	window.alert = function(){};
	alert('无法用alert()显示了!');
	window.alert = old_alert;
	alert('又可以用alert()了!');
*/
/*2.把自己的代码全部放入唯一名字空间APP中,大大减少全局变量冲突的可能
	许多组名的JavaScript库都是这么干的:jQuery,YUI,underscore等等
	var MYAPP = {};
	MYAPP.name = 'myapp';
	MYAPP.version = 1.0;
	MYAPP.foo = function(){
		return 'foo';
	};
*/
/*3.解决块级作用域,ES6引入新关键词let,用let代替var
	let可以声明一个块级作用域
	function foo(){
		var sum =0;
		for(let i =0;i<100;i++){
			sum+=i;
		}
		i+=1;
	}
	foo();
*/
/*4.用var  let声明的都是变量
	常量
		ES6之前全部用大写的变量来表示这是一个常量,var PI=3.14;
		ES6引入关键词const定义常量,const let 具有块级作用域
	//var PI = 3.14;
	const PI =3.14;
	console.log(PI)
*/
/*5.传统把一个数组的元素分别赋值给几个变量
	var array = ['hello','javascript','ES6'];
	var x = array[0];
	var y = array[1];
	var z = array[2];
*/
/*6.解构赋值
	var [x,y,z]=['hello','javaccript','Es6'];
	console.log('x = '+x+',y='+y+',z='+z);
	let[x,[y,z]]=['hello',['javascript,'ES6']];
	let[,,z]=['hello','javascript','Es6'];
*/
/*7.从一个对象取出若干属性
	var person ={
		name:'小明',
		age:20,
		gender:'male',
		passport:'G-12345678',
		school:'No.4 middle school'
	};
	var {name,age,passport} =person;
	console.log('name='+name+',age='+age+',passport ='+passport);
*/
/*8.使用解构赋值读取属性值
	var person = {
		name:'小明',
		age:20,
		gender:'male',
		passport:'G-12345678',
		school:'No.4 middle school',
		address:{
			city:'Beijing',
			street:'NO.1 Road',
			zipcode:'100001'
		}
	}
	var {name,address:{city,zip}} = person;
	console.log(name);
	console.log(city);
	console.log(zip);
	console.log(address);
*/
/*9.解构赋值
	var person = {
		name:'小明',
		age:20,
		gender:'male',
		passport:'G-12345678',
		school:'No.4 middle school'
	};
	let {name,passport:id}=person;
	console.log(name);
	console.log(id);
	console.log(passport);//passport不是变量,二是为了让变量id获取passport
*/
/*10,解构赋值
	//大大简化代码
	var x=1,y=2;
	[x,y]=[y,x];
	//快速获取当前页面的域名和路径
	var {hostname:domain,pathname:path}=location;
	function buildDate({year,month,day,hour=0,minute=0,second=0}){
		return new Date(year+'-'month+'-'+day+''+hour+':'+minute+':'+second);
	}
	buildDate({year:2017,month:1,day:1});
*/
/*11.对象的方法
		对象的属性值是函数而已
	var xiaoming={
		name:'小明',
		birth:1990
	};
	var xiaoming={
		name:'小明',
		birth:1990,
		age:function(){
			var y =new Date().getFullYear();
			return y - this.birth;
		}
	};
	console.log(xiaoming.age);
	console.log(xiaoming.age());
*/
/*12.this指向问题
	function getAge(){
		var y = new Date().getFullYear();
		return y -this.birth;
	}
	var xiaoming ={
		name:'小明',
		birth:1990,
		age:getAge
	};
	console.log(xiaoming.age());
	console.log(getAge());
*/
/*13.作为对象方法的this
	var xiaoming = {
		name:'小明',
		birth:1990,
		age:function(){
			var that =this;
			function getAgeFromBirth(){
				var y = new Date().getFullYear();
				return y - that.birth;
			}
			return getAgeFromBirth;
		}
	};
	
	console.log(xiaoming.age());
*/
/*14.严格模式下提示
					UNcaught TypeError:Cannotread property of undefined
	'use  strict';
	var xiaoming = {
		name:'小明',
		birth:1990,
		age:function(){
			var y =new Date().getFullYear();
			return y -this.birth;
		}
	};
	var fn =xiaoming.age;
	fn();//NaN
*/
/*15.内部函数this指向问题
	var xiaoming ={
		name:'小明',
		birth:1990,
		age:function(){
			function getAgeFromBirth(){
				var y = new Date().getFullYear();
				return y -this.birth;//t作为函数调用指向window
			}
			return getAgeFromBirth();
		}
	}
*/
/*16.that 捕获this 解决内部函数this指向问题
	var xiaoming = {
		name:'小明',
		birth:1990,
		age:function(){
			var that = this;
			function getAgeFromBirth(){
				var y =new Date().getFullYear();
				return y -that.birth;
			}
			return getAgeFromBirth();
		}
	};
	console.log(xiaoming.age());
*/
/*17.apply()call()函数方法修改this指向
	function getAge(){
		var y = new Date().getFullYear();
		return y - this.birth;
	}
	var xiaoming = {
		name:'小明',
		birth:1990,
		age:getAge
	};
	console.log(xiaoming.age());
	console.log(getAge.apply(xiaoming,[]));
	Math.max(3,5,4);
	Math.max.apply(null,[3,5,4]);
*/
/*18.编写高阶函数,就是让函数参数能够接收别的函数
	function add(x,y,f){
		return f(x)+f(y);
	}
	add(-5,6,Math.abs)
	x = -5;
	y = 6;
	f = Math.abs;
	f(x)+f(y)==>Math.abs(-5)+Math.abs(6)==>11;
	return 11;
*/
/*19.map()数组方法遍历数组中每一项
	function pow(x){
		return x*x;
	}
	var arr = [1,2,3,4,5,6,7,8,9];
	var resulet = arr.map(pow);
	console.log(resulet);
*/
/*20.for  循环实现和map一样遍历数组中每个元素
	var  f =function (x){
		return x*x;
	}
	var arr = [1,2,3,4,5,6,7,8,9];
	var result =[];
	for(var i =0;i<arr.length;i++){
		result.push(f(arr[i]));
	}
*/
/*21.
	var  arr =[1,2,3,4,5,6,7,8,9];
	console.log(arr.map(String));
*/
/*22.构造函数返回return是无效的
	function Cat(name,color){
		this.name = name;
		this.color = color;
	}
	var cat1 = new Cat();
	console.log(cat1); 
*/

</script>
</html>