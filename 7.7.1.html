<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title> </title>
<style>

</style>
</head>
<body>
	
</body>
<script>
/*1.声明变量用var
	声明的变量可以保存不同类型值,不推荐修改初始化数据类型;
	var 声明的变量是局部变量
	//var message;//松散型,可以用来保存任何类型的数据,var是声明;
	//var message = 'hi';//声明变量并初始化,就是给变量赋一个值;
	//message = 100;//修改变量值的同时修改值的类型,不建议修改变量所保存值的类型;
	function test(){
		var message = 'hi';//使用var操作符定义的变量将成为定义该变量的作用域的局部变量;
	}	
	test();
	console.log(message);//局部变量在函数退出后立即销毁,
*/
/*2.一条语句定义多个变量,中间用逗号隔开;
	var message = 'hi',
		found = false,
		age = 29;
*/
/*3.var声明的变量但未初始化(未赋值)则这个变量返回是undefined,
	变量名,常量,关键字是原始表达式,有返回值
	var message;
	console.log(message);
	console.log(message==undefined);
	console.log(message===undefined);
*/
/*4.对声明没有初始化的变量返回值undefined
	对未声明的变量返回结果是错误
	typeof检测操作数类型,测试声明变量未初始化则是undefined
	typeof检测操作数类型,测试未声明变量这个复杂表达式返回undefined
	小技巧,已声明且初始化变量,当typeof返回undefined时则可断定是没有声明的变量
	一般都是很严格的使用var,要么就是给初始化,常见的错误也是打错字儿造成未声明变量
	var message;
	console.log(message);
	//console.log(age);
	console.log(typeof message);声明没有初始化
	console.log(typeof age);//未声明,typeof则也是undefined
*/
/*5.空对象指针,空对象指针
	var car = null;
	console.log(typeof null);
*/
/*6.将来用于保存对象,定义的变量准备在将来用于保存对象
	if(car!=null){
		//
	}
*/
/*7.undefined是null生的
	undefined不会被显式的赋值给一个变量
	null会显式的赋值给一个变量,因为意图保存对象.
	console.log(null==undefined);
*/
/*8.非空字符串转换成布尔值true,''转布尔值false;
	非0数字转换成布尔值true,0NaN-0转布尔false;
	对象转布尔值true,null转布尔false;
	undefined转布尔值永远是false;
	var message = 'hello world';
	var messageAsBoolean = Boolean(message);
	console.log(messageAsBoolean);
	var str = '';
	var strAsBoolean = Boolean(str);
	console.log(strAsBoolean);//false
	var num = 0;
	var numAsBoolean = Boolean(num);
	console.log(numAsBoolean);//false
	var num2 = NaN;
	var num2AsBoolean = Boolean(num2AsBoolean);
	console.log(num2AsBoolean);//false
	var emptyObject = null;
	var emptyObjAsBoolean = Boolean(emptyObject);//false
	console.log(emptyObjAsBoolean);
	var und = undefined;
	var undAsBoolean = Boolean(und);
	console.log(undAsBoolean);//false
*/
/*9.8进制字面量以0开头,后面的数值(0~7),在严格模式下是无效的,会导致JS抛出错误;
	var intNum = 55;//十进制整数
	var octalNum1 = 070;//8进制字面量,以8为基数,第一位是0,然后是(0~7);
	var octalNum2 = 079;//8进制字面量,但是超出了(0~7),前导0忽略,后面的数值当做十进制79;
	var octalNum3 = 08;//前导0忽略,解析为8;
*/
/*10.在进行算术计算时,所有以8进制16进制表示的数字最终都将换成十进制数值.
	var hexNum1 = 0xA;//10
	var hexNum2 = 0x1f;//开头0x,后跟(0~9及A~F)31;
*/
/*11.浮点数,占用内存空间是整数值的两倍
	科学计数法e
	永远不要则是某个特定的浮点数值
	var floatNum1 = 1.1;//小数点后必须至少有一位数字;
	var floatNum2 = 0.1;//小数点后面必须至少有一位数字,
	var floatNum3 = .1;//小数点前面可以没有整数,不推荐这种写法
	var floatNum4 = 1.;//后面么有数字,解析为1;
	var floatNum5 = 10.0;//本身表示一个整数,则该值转换为整数10
	var floatNum =3.125e7;//等于31250000,e10的次幂;
*/
/*12.isNaN()函数判断传入的参数是否"不是数值"
	接收到参数后,会转换为数值,不是数值则返回true
	console.log(NaN==NaN);//NaN不与任何值相等,包括本身;
	console.log(isNaN(NaN));
	console.log(isNaN(10));
	console.log(isNaN('10'));
	console.log(isNaN('blue'));
	console.log(isNaN(true));
*/
/*13.Number()转型函数,接收任何类型数据,转成数值;
	字符串转数值有点特殊,只包含数字的字符串,直接转成十进制
		空字符串转成0
		前导0忽略
	布尔值到数值,true1false0
	对象转成数值
	null转成数值0
	undefined转成数值NaN
	var num1 = Number('Hello world!');
	console.log(num1);//纯字符串转成数值NaN;
	var num2 = Number('');//空字符串转成数值0;
	console.log(num2);
	var num3 = Number('000011');//字符串只包含数值,则转换为十进制,忽略前导0;
	console.log(num3);
	var num4 = Number(true);
	console.log(num4);
	console.log(Number(null));//0
	console.log(Number(undefined));//NaN
*/
/*14.字符串转成数值,parseInt()
	var num1 = parseInt('1234blue');
	console.log(num1);
	var num2 = parseInt('');//NaN
	console.log(num2);
	var num3 = parseInt('0xA');//16进制转成10进制,能够识别整数格式
	console.log(num3);
	var num4 = parseInt('070');//8进制
	console.log(num4);
	var num5 = parseInt(22.5);
	console.log(num5);
	var num6 = parseInt('70');
	console.log(num6);
	var num7 = parseInt('0xf');
	console.log(num7);
*/
/*15.转义字符
	字符串不可变;
	var text = "This is the letter sigma:\u03a3";
	console.log(text);
	var lang = 'Java';
	lang = lang+"Script";
	console.log(lang);
*/
/*16.toString()方法
	这是Object对象上的方法,所以数值,布尔值,对象,字符串值,都有这这个方法
	var age = 11;
	var ageAsString = age.toString();
	console.log(ageAsString);
	var found = true;
	var foundAsString = found.toString();
	console.log(foundAsString);
*/
/*17.String()转型函数
	Number()
	Boolean()
	类型转换
	var value1 = 10;
	var value2 = true;
	var value3 = null;
	var value4;
	console.log(String(value1));
	console.log(String(value2));
	console.log(String(value3));
	console.log(String(value4));
*/
/*18.前置型++ --反正操作数是铁定要变的
	但是++ --前置作为整个表达式的返回值是执行++ --后的
	//var age = 29;
	//++age;
	//console.log(age);
	//--age;
	//console.log(age);
	var age = 29;
	var anotherAge = --age+2;
	console.log(age);
	console.log(anotherAge);
	var num1=2;
	var num2=20;
	var num3=--num1+num2;
	var num4=num1+num2;
	console.log(num3);
	console.log(num4);
*/
/*19.后置型++ --不影响语句
	但是操作数肯定是变的
	表达式语句,带有副作用的表达式,函数调用,赋值,声明语句
	var age=29;
	var num=age++;
	console.log(num);
	console.log(age);
	var num1=2;
	var num2=20;
	var num3=num1-- + num2;
	var num4=num1+num2;
	console.log(num3);
	console.log(num4);
*/
/*20.前置++;后置++
	 前置--;后置--
	 适用于任何值,布尔,字符串,对象,浮点数都转成数值再说
 	var s1 ='2';
 	var s2 ='z';
 	var b =false;
 	var f =1.1;
 	var o={
 		valueOf:function(){
 		return -1;
 		}
 	};
 	s1++;
 	console.log(s1);
 	s2++;
 	console.log(s2);
 	b++;
 	console.log(b);
 	o++;
 	console.log(o);
 	f++;
 	console.log(f);
*/
/*21,一元加
	R 1 num→num
	转换为数字牵涉到隐式类型转换Number();
	var num = 25;
	num = +num;
	console.log(num);
	var s1 = '01';
	var s2 = '1.1';
	var s3 = 'z';
	var b =false;
	var f = 1.1;
	var o = {
		valueOf:function(){
			return -1;
		}
	};
	s1 = +s1;
	console.log(s1);
	s2 = +s2;
	console.log(s2);
	s3 = +s3;
	console.log(s3);
	b = +b;
	console.log(b);
	f = +f;
	console.log(f);
	o = +o;
	console.log(o);
*/
/*22.一元减
	求反;
	R 1 num→num;优先级高于一元加
	var s1 = '0.1';
	var s2 ='1.1';
	var s3 = 'z';
	var b = false;
	var f = 1.1;
	var o = {
		valueOf:function(){
			return -1;
		}
	};
	s1=-s1;
	s2=-s2;
	console.log(s1);
	console.log(s2);
	s3=-s3;
	console.log(s3);
	b=-b;
	f=-f;
	o=-o;
	console.log(b);
	console.log(f);
	console.log(o);
*/
/*23.逻辑非
	先把操作数变成布尔值,再对其求反;
	!!相当于Boolean()转型函数;
	console.log(!false);
	console.log(!"blue");
	console.log(!0);
	console.log(!NaN);
	console.log(!'');
	console.log(!12345);
*/
/*24.逻辑与&&:同为真时,方为真;第一个操作数是真,则进行第二个操作数运算,返回第二个操作数;
							  第一个操作数是假,则返回false;
	逻辑或||:同为假时,方为假;第一个操作数是假,则进行第二个操作数运算,返回第二个操作数;
							  第一个操作数是真,则返回第一个操作数;
	都是短路操作符,当左边的表达式能决定返回结果时,不再进行右侧计算;
	var result = true && false;
	console.log(result);
	var found = false;
	var result = found && someUndefinedVariavle;
	console.log(result);
*/
/*25.逻辑或||防止赋值null或者undefined值
	抓住同为假时方为假
	有一个为真即为真
	短路操作符
	var myObject = preferredObject || backupObject;
	避免为变量赋null或undefined值;
	变量 myObject将被赋予等号后面两个值中的一个;
	变量preferredObject中包含有限赋给变量myObject的值;
	变量backupObject负责在preferredObject中不包含有效值的情况下提供后备值;
	如果preferredObject的值不是null,那么它的值将被赋予myObject;
	如果preferredObject的值是null,则将backupObject的值赋予myObject;
*/
/*26.加法操作+
	优先进行字符串拼接
	转换好像也是转成字符串
	()括起来
	var result = 1+2;
	var result1 = 5+5;
	console.log(result1);
	var result2 = 5+'5';
	console.log(result2);
	var num1 = 5;
	var num2 = 10;
	var message = 'The sum of 5 and 10 is'+(num1+num2);
	console.log(message);
*/
/*27.减法好像就是转换成数值再操作
	var result=2-1;
	var result1 = 5-true;
	var result2 = NaN-1;
	var result3 = 5-3;
	var result4 = 5-'';
	var result5 = 5-'2';
	var result6 = 5-null;
*/
/*28.字符串比较的是字符编码
	一个操作数是数值,另一个非数值操作数转换为数值
	var result1 = 5>3;
	var result2 =5<3;
	console.log(result1);
	console.log(result2);
	var result3 = 'Brick'<'alphabet';//字符串比较的是其对应的字符编码
	var result4 = 'Brick'.toLowerCase()<'alphabet'.toLowerCase();
	console.log(result4);
*/
/*29.字符串比较数值
	字符串转成数值如果是NaN则结果是false
	任何数和false比较都是返回false;
	var result='23'<3;
	console.log(result);
	var result1 = 'a'<3;
	console.log(result1);
*/
/*30.相等==不相等!=
	 先转换成数值再比较
	console.log(null==undefined);
	console.log(NaN==NaN);
	console.log(5==NaN);
	console.log('NaN'==NaN);
	console.log(NaN!=NaN);
	console.log(false==0);
	console.log(true==1);
	console.log(true==2);
	console.log(undefined==0);
	console.log(null==0);
	console.log('5'==5);
*/
/*31.全等===不全等!==
	 仅比较不转换
	console.log('55'===55);
	console.log('55'!=55);
	console.log('55'!==55);
	console.log(null===undefined);
*/
/*32.条件操作符?:
	基于布尔类型表达式求值,决定给变量赋什么值
	variable = boolean_expression ? true_value : false_value;
	//基于boolean_expression求值结果,决定给变量variable赋什么值;
	var max = (num1>num2) ? num1 : num2;
*/
/*33.复合赋值操作,简化赋值操作
	var num = 10;
	num = num + 10;
	num+=10;//复合赋值操作
*/
/*34,逗号操作符
	var num1=1,num2=2,num3=3,num4=4;
	//一条语句中执行多个操作
*/
	
</script>
</html>