<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Object </title>
<style>
#div1 div{
	width: 200px;
	height: 200px;
	border: 1px solid #000;
	display: none;
}
.active{
	background-color: red;
}
</style>
<script>
	window.onload=function(){
		var Oparent = document.getElementById('div1');
		var aInput = Oparent.getElementsByTagName('input');
		var aDiv = Oparent.getElementsByTagName('div');
		for(var i=0;i<aInput.length;i++){
			aInput[i].index=i;
			aInput[i].onclick=function(){
				for(var i =0;i<aInput.length;i++){
					aInput[i].className="";
					aDiv[i].style.display='none';
				}
				this.className='active';
				aDiv[this.index].style.display='block';
			}		
		}
	}
</script>
</head>
<body>
	<div id="div1">
		<input type="button"value="1">
		<input type="button" value="2">
		<input type="button" value="3">
		<div style="display:block">111</div>
		<div>222</div>
		<div>333</div>
	</div>
	
</body>
<script>
/*1.早起创建对象的方法
	var person1 = new Object();
	person1.name='Nicholas';
	person1.age=20;
	person1.sayHi=function(){
		alert(this.name);
	}
	console.log(person1.name);
	var person2 = new Object();
	person2.name='ming';
	person2.sayHi=function(){
		alert(this.name)
	};
	person2.sayHi();
*/
/*2.对象字面量创建对象
	var person={
		name:'Nichloas',
		age:29,
		sayHi:function(){
			alert(this.name);
		}
	}
*/
/*3.工厂模式创建对象
			创建对象的封装函数
	function person(name,age){
		var o = new Object();//创建对象的函数封装
		o.name=name;
		o.age=age;
		o.sayName=function(){
			alert(this.name);
		}
		return o;//返回对象
	}
	console.log(person('Nicholas',28));//函数调用返回对象o
	var person1=person('ming',30);//调用函数返回给对象
	console.log(person1.name);//对象的属性
	无数次的调用函数,每次都放一个包含二个属性和一个方法的对象
	工厂模式虽然解决了创建多个相似对象的问题,但是却没有解决对象是别的问题
	怎么知道一个对象的类型
*/
/*4.构造函数创建对象4步骤
	function Person(name,age,job){
		this.name=name;
		this.age=age;
		this.job=job;
		this.sayName=function(){
			alert(this.name);
		}
	}
	var person1 = new Person('Nichlas',29,'software Engineer');
	var person2 = new Person('ming',30,'clear');
	console.log(person1.name);
	console.log(person2.name);
	console.log(person1.constructor==Person);//true
	console.log(person2.constructor==Person);//true
	console.log(person1 instanceof Person);//trur;
	console.log(person2 instanceof Person);//true;
	console.log(person1 instanceof Object);
	console.log(person2 instanceof Object);
*/
/*5.构造函数中方法多次重建
	function Person(name,age,job){
		this.name=name;
		this.age=age;
		this.job=job;
		this.sayName=function(){
			alert(this.name);
		}
	}
	var  person = new Person('Nicholas',29,'sofware Engineer');
	person.sayName();//Nicholas
	Person('ming',27,'Doctor');
	window.sayName();//普通函数调用
	var o = new Object();
	Person.call(o,'king',25,'Nurse');
	o.sayName();//某个特殊对象的作用域中调用Person(),这里是在对象o的作用域中调用的
				//对象Person的对象o作用域中
*/
/*6.创建两个完成同样任务的funtion实例的确没有必要.
	function Person(name,age,job){
		this.name=name;
		this.age=age;
		this.job=job;
		this.sayName=sayName;
	}
	function sayName(){
		alert(this.name);
	}
	var person1=new Person('Nichloas',29,'software Engineer');
	var person2=new Person('Greg',27,'Doctor');
	console.log(person1.name);
*/
/*7.基本类型赋值
			值的复制
	引用类型的赋值
			值和引用的复制
	引用类型的比较是值和引用的比较
			引用类型的赋值是在内存中开辟不同的空间存储
	var obj1=new Object();
	var obj2=new Object();
	console.log(obj1==obj2);
	var a =[1,2,3];
	var b =a;
	console.log(a==b);
	var a =[1,2,3];
	var b =[1,2,3];
	console.log(a==b);
*/
/*8.常见的一个一个给对象绑定函数的方法
	var arr = [1,2,3,4,5];
	arr.sum=function(){
		var result = 0;
		for(var i=0;i<this.length;i++){
			result+=this[i];
		}
		return result;
	}
	console.log(arr.sum());
	var arr2 = [2,2,2,2,2];//arr2也想拥有这种方法,就需要再次给arr2绑定sum
	arr2.sum=function(){
		var result=0;
		for(var i=0;i<this.length;i++){
			result+=this[i];
		}
		return result;
	}
	console.log(arr2.sum());
*/
/*9.写在构造函数的prototype下面
	var arr = [1,2,3,4,5];
	var arr2 =[2,2,2,2,2];
	//prototype写在构造函数下
	Array.prototype.sum=function(){
		var result = 0;
		for(var i =0;i<this.length;i++){
			result+=this[i];
		}
		return result;
	}
	console.log(arr.sum());
	console.log(arr2.sum());
*/
/*10.普通方法与继承方法优先级
	var arr =[1,2,3];
	//arr.number=10;
	Array.prototype.number=20;
	console.log(arr.number);//普通属性大于继承而来的属性
	console.log(arr.number);//20去掉普通属性
*/ 
/*11.//构造函数变成原型模式
	function Person(name,age){
		this.name=name;
		this.age=age;
		//构造函数中普通方法
		//this.sayHi=function(){
			//alert(this.name);
		//}
	}
	Person.prototype.sayHi=function(){
		alert(this.name);
	}
	var person1 = new Person('Nicholas',30);
	console.log(person1.name);
	var person2 = new Person('ming',38);
	console.log(person2.name);
	console.log(person1.sayHi==person2.sayHi);//true来自同一个函数
	//变化的就不能写在原型上
	//通过原型对象改造构造函数创对象方法
			//相同的属性和方法可以加载原型上
			//属性写在构造函数中,方法写在原型中
		function 构造函数(){
			this.属性;
		}
		构造函数.prototype.方法=function(){};
		var 对象1 = new  构造函数();
*/
	//面向对象的选项卡 

</script>
</html>
